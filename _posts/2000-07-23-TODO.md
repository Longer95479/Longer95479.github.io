- [ ] 特征提取
    - [ ] 数据关联
    - [ ] 数据结构 frame::_features and frame::_track_id
    - [ ] 流程
[ ] 运动估计
  [] 数据结构
  [] 流程
[] 后端优化 
  [] 数据结构

---

- [x] 数据集读取
  - [x] json
  - [x] csv (包含 mag 数据)

- [x] 可视化：
  - [x] 把地图显示在 rviz 上，方便调试
    - [x] 尺度上的变换
    - [x] 左上角为 (0, 0), x 向右为正，y 向下为正，x 指向北
    - [x] 定义地图系（NED，相对于 rviz 的世界系）
    - [x] 解决读取不到 .dae 文件的 bug：打开rviz的终端找不到 slampose包
    - [x] mesh 不显示：尺度变换错误，尺度太小导致看不见
    - [x] 确认 marker 的固联坐标系：见 手写笔记

- [x] 确定状态量、 观测量、因子（约束）：
  - [x] 状态
    - [x] geo_T_slamp
  - [x] 观测量 与 因子
    - [x] Local Factor(VIO) 
    - [x] GPS Factor 
    - [x] Magnetmeter Factor

- [x] 确定数据结构
  - [x] 阅读 test_PGO
  - [x] 安装源码版 pycolmap

- [x] 初始化：
  - [x] NED 坐标系下轨迹各帧初始值 = SE(3) * slam_pose
  - [x] 先将 localkit 的经纬度变换到 地理系 
  - [x] 确定平移部分：x、y 从 slampose 和 localkit 最近邻点对来获取，然后取个平均
  - [x] 确定旋转部分：yaw从磁力计获取、或者从已有轨迹和地图对齐考虑


- [x] 约束与优化：
  - [x] Local Factor(VIO): slampose 帧间位姿
  - [x] wifi/GPS Factor: localkit 找时间上最近邻的帧施加约束
  - [x] manhattan yaw
    - [x] 施加 yaw offset
    - [x] 读取 mgw 数据
    - [x] 预处理 mgw 数据
    - [x] 构建约束，和 location 一起
  - [ ] Magnetmeter Factor: 磁力计施加的 yaw 约束
  - [ ] huber 鲁棒核函数

- [x] 数据输出
  - [x] 结果转换为 rpy
  - [x] 结果打包到 list
  - [x] 按指定格式，写到指定位置下的 csv
  - [x] 0-6 数据集rosbag 图片 265 张，但 slampose 有 267 个，转成 rosbag 有点问题

- [ ] 高频传播：
  - [ ] imu propagate

一些初步结论：
- mgw 姿态比 slampose 的姿态好，因此输出只输出 mgw 的角度
- mgw 姿态 和 slampse 的平移初始值共同构成 AbsPose 先验，这个先验的方差如果设置小，也就ishi比重大一些后，会导致整体的轨迹尺度发散，这就导致 mgw 的权重无法太大，因此变成了辅助定位

第一帧使用 mag_in_imu 计算的 T 有误，甚至会影响到尺度
- 0
       mgw      slampose
  - 0: back	b
  - 1: forward	b
  - 2: b        b
  - 3: f        b
  - 4: b	b
  - 5: f	b
  - 6: b	b
  - 7: b	b
  - 8: f	b

旋转错误
- 0-4 
- 0-8
- 1-0
- 1-1	

---

pytorch 与其他框架训练的网络如何交互：onnx 开放神经网络交换

分为用于实验的即时模式，和用于高性能执行的图形模式


反向模式自动微分，Chainer
- 写一个子程序计算函数值 f(x)
- 


backpropagation algorithm:
- 本质上是链式法则

```
n = 4, N = 7

1    2    3    4
 5(1,2)  6(1, 3, 4)
      7(5, 6)

x_i <- f_i(X_{/Pi(i)})
i = n + 1, ... , N

```



The biggest difference is that autodiff can differentiate algorithms, not just expressions


---

2024-04-20

PyTorch is a Python-based scientific computing package serving two broad purposes:

A replacement for NumPy to use the power of GPUs and other accelerators.

An automatic differentiation library that is useful to implement neural networks.


---


[Pi0](https://www.bilibili.com/video/BV1mERzYvE4j/?spm_id_from=333.1007.tianma.2-2-5.click&vd_source=e371652571b1539bbd501fb7adb6cfc4)


1. 社区更好地掌握了创建可迁移通用模型的方法，使得微调或零样本迁移到其他机器人上成为可能
2. 视觉语言模型，让机器人能够理解环境中的语义
3. 强化学习领域的进步，使系统的健壮性、可靠性、性能得到突破


---

[](https://www.bilibili.com/video/BV1qqUaYmENu/?spm_id_from=333.788.recommend_more_video.-1&vd_source=e371652571b1539bbd501fb7adb6cfc4)

LLM：文字 -> 文字
VLM：图片+文字 -> 文字
VLA：图片+文字+Robot Action Data -> Robot Action Data

通用模型比专用系统表现更好
纳入异质数据源显著提升了繁华能力


训练基础模型的流程：
- 预训练：爬虫、筛选巨大的预训练数据集 -> 设计网络架构（一般是 Transformer）-> 设计训练目标
- 



---

C 语言模板库得到的启示：

如何在 C 语言中构建 类 呢
- 使用结构体 struct
  - property：需要初始化的成员变量
  - value：用于缓存
  - 函数指针

使用的步骤：
 - 核心思路是三步走：
    - 成员变量（普通变量+函数指针）初始化（赋初值）
    - 通过函数指针调用算法初始化函数
    - 再通过函数指针调用逻辑执行函数

 - C++ 有构造函数，而在 C 里，则需要单独写一个 全局函数，用于将 函数指针 绑定（被赋值）到某个具体的函数实现上


---

- [ ] 把 DD 相关的写完，总结好

- [ ] 理解 plnet 的 pipline 以及 数据结构
  - [ ] pipline、基本公式（如果有的话）
  - [ ] 如何在代码上把 onnx 转成 engine
  - [ ] 数据结构

- [ ] 自己实现一个智能指针

- [ ] 初学 diffusion 原理

- [ ] 初学 RL 原理



---

依赖：
- NvOnnxParser.h
- 3rdparty/tensorrtbuffer/include/buffers.h
- Eigen/core
- opencv.hpp


resize 图片相关:
- input_width, input_height


---

keynote: The Real Problem of C++ - Klaus


c++ has a safety problem
- yes if you still have the "classic C++" midset

always choose perfomence, cuz:
- YES: safe over fast
- NO: fast over safe

topic:
- Bound Safety
- Type Safety
- Initialization Safety
- Lifetime Safety
- Undefined Behavior
 
1. Bound Safety	

The first part about ranges and not using loops, that's mainly about using a declarative style - so that your code says what it does, but not how it does that, and every common part of the logic (like take) is a separate library function (tested billions times unlike the for loop you make instead). 



- the "Ranges" style.
```
std::ranges::sort()
```

和 `std::sort` 有什么区别?

- **No Raw Loops**

代码示例见视频


2. undedined Behavior

- using `constexpr`
`-std=c++20` 才好用，否则无法在 constexpr 的函数内创建 vector 等数据结构

- complier explorer 是个好工具

- 函数只能全特化，不能偏特化（全特化意味着template<>，也就是括号里得为空，然后在函数名后3所有具体的类型名）


---


Back to the Basics

- Tour to C++

1. prefer range-for 

why do this: 
```
for ( auto i = begin(c); i != end(c); i++ ) { ... use(*i); ...}
```

when you can do this: 
```
for (auto& e: c) { ... use(e); ... }
```
2. Use smart pointers effectively, but still ** use lots of raw * and & **, they're great!

Dont's use owning `*`, `new` or `delete`. Except: Encapsulated inside the implementation of low-level data structures.

For "new", use `make_unique` by default, make_shared if it will be shared. For "delete", write nothing.

Example: 
- c++98 (now mostly wrong)
```c++
widget* factory();
void caller()
{
  widget* w = factory();
  gadget* g = new gadget();
  use( *w, *g );
  delete g;
  delete w;
}
```
- Modern C++:
```c++
unique_ptr<widget> factory();
void caller()
{
  auto w = factory();
  auto g = make_unique<gadget>();
  use( *w, *g );
}
```

NB: Non-Owing */& Are Still Great.

Why: 被调用者在调用者的生命周期内，不需要做所有权转移（you don't need ownership transfer down to call stack unless you're going to take something out of the call stack）

Example:
- C++98 "Classic":
```c++
void f( widget& w )  // if required
{
  use(w);
}

void g( widget* w )  // if optional
{
  if(w) use(*w);
}
``` 
- Modern C++ "Still Classic":
```c++
void f( widget& w )  // if required
{
  use(w);
}

void g( widget* w )  // if optional
{
  if(w) use(*w);
}
``` 
How to use those functions:
```c++
auto upw = make_unique<widget>();
...
f( *upw );

auto spw = make_shared<widget>();
...
g( spw.get() );
```

Antipatterns Hurt Pain Pain

Antipattern #1: Parameters (Note: Any refcounted pointer type.)
```
void f( refcnt_ptr<widget>& w )
{
  use(*w);
} // ?

void f( refcnt_ptr<widget> w )
{
  use(*w);
} // ?!?!
```
前者想避免计数，但会带来歧义：要更改指针的指向吗

后者带来性能上的恶化：每次进出函数都会递增和递减，而这些操作是原子操作，需要同步，因此开销并不小。

在这二种进行选择是一种 过早悲观：因为在都很复杂的操作中选择了更快，或者说在更快和更复杂中进行选择。
因此不如直接使用 raw */&

Antipattern #2: Loops (Note: Any refcounted pointer type.)
```
refcnt_ptr<widget> w = ...;
for (auto& e: baz) {
  auto w2 = w; // ?!?!?!?!
  use( w2, *w2, w, *w, whatever);
} // ?!?!?!?!
```
在循环中复制智能指针，缺点仍是带来大的开销

example:
In late 2013, Facebook RocksDB changed from pass-by-value shared_ptr to pass */&. QPS improveed 4x (100K to 400K) in one benchmark. 
[http://tinyurl.com/gotw91-example](http://tinyurl.com/gotw91-example)

什么时候才 copy/assigns smart pointer?

- refcounted smart pointers are about managing the owned object's lifetime.

- Don’t pass a smart pointer as a function parameter unless you want to use or manipulate the smart pointer itself, such as to share or transfer ownership.

- Prefer passing objects by value, *, or &, not by smart pointer.

- Express a “sink” function using a by-value unique_ptr parameter.

- Use a non-const unique_ptr& parameter only to modify the unique_ptr.

- Don’t use a const unique_ptr& as a parameter; use widget* instead.

- Express that a function will store and share ownership of a heap object using a by-value shared_ptr parameter.

- Use a non-const shared_ptr& parameter only to modify the shared_ptr. Use a const shared_ptr& as a parameter only if you’re not sure whether or not you’ll take a copy and share ownership; otherwise use widget* instead (or if not nullable, a widget&).

---

一个 procedure A 调用另一个 procedure B 时，计算机需要干的事情：

1. 转移控制
2. 转移数据
3. 分配和释放内存


```c
int fact(int n)
{
  int result;
  if (n <= 1)
    result = 1;
  else
    result = n * fact(n-1);
  return result;
}
```


main() -> fact(n) -> fact(n-1) 即将-> fact(n-2)
的 call stack: 

      (stack top)
  +-----------------+ <-- stack pointer (SP)
  |      n - 2      | \  
  +-----------------+  | 
  |      result     |   > frame for fact(n-1)
  +-----------------+  | 
  |  saved register | /  
  +-----------------+
  |  return address | \  
  +-----------------+  |  
  |      n - 1      |  | 
  +-----------------+   > frame for fact(n)
  |      result     |  | 
  +-----------------+  |
  | saved registers | /
  +-----------------+
  |  return address | \  
  +-----------------+  | 
  |        n        |   > frame for main()
  +-----------------+  | 
  |       ...       | /  
  +-----------------+
    (stack "bottom")

---


# 设计模式

[工厂模式比较](https://refactoringguru.cn/design-patterns/factory-comparison)

- 构建方法：返回一个对象的函数或方法
```c++
class number {
  number(v): value(v) {}
  unique_ptr<widget> nextFactory() {
    return make_unique<number>(value + 1);
  }
private:
  int value;
}
```

- 简单工厂模式
简单工厂通常没有子类。 但当从一个简单工厂中抽取出子类后， 它看上去就会更像经典的工厂方法模式了。
```c++
class Button {/* ... */}; 
class WinButton: Botton {/* ... */};
class MacButton: Botton {/* ... */};

class ButtonFactory {
  unique_ptr<Button> create(string type) {
    switch (type) {
      case "Mac": return make_unique<MacButton>
      case "Win": return make_unique<WinButton>
      default: cout << "Wrong type." << endl; return nullptr;
    }
  }
}
```


- 工厂方法模式
```c++
class Button {/* ... */}; 
class WinButton: Botton {/* ... */};
class MacButton: Botton {/* ... */};

class ButtonFactory {
  vitual unique_ptr<Botton> createButton()=0;
}

class MacButtonFactory: ButtonFactory{
  unique_ptr<Botton> createButton() {
    return make_unique<MacButton>();
  }
}

class WinButtonFactory: ButtonFactory{
  unique_ptr<Botton> createButton() {
    return make_unique<WinButton>();
  }
}
```


- 抽象工厂

抽象工厂 是一种创建型设计模式， 它能创建一系列相关或相互依赖的对象， 而无需指定其具体类。

什么是 “系列对象”？ 例如有这样一组的对象：运输工具+ 引擎+ 控制器 。 它可能会有几个变体：

1. 汽车+ 内燃机+ 方向盘
2. 飞机+ 喷气式发动机+ 操纵杆

如果你的程序中并不涉及产品系列的话， 那就不需要抽象工厂。

再次重申， 许多人分不清抽象工厂模式和声明为 abstract的简单工厂。 不要犯这个错误！


