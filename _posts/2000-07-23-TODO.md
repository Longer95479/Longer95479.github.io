- [ ] 特征提取
    - [ ] 数据关联
    - [ ] 数据结构 frame::_features and frame::_track_id
    - [ ] 流程
[ ] 运动估计
  [] 数据结构
  [] 流程
[] 后端优化 
  [] 数据结构

---

- [x] 数据集读取
  - [x] json
  - [x] csv (包含 mag 数据)

- [x] 可视化：
  - [x] 把地图显示在 rviz 上，方便调试
    - [x] 尺度上的变换
    - [x] 左上角为 (0, 0), x 向右为正，y 向下为正，x 指向北
    - [x] 定义地图系（NED，相对于 rviz 的世界系）
    - [x] 解决读取不到 .dae 文件的 bug：打开rviz的终端找不到 slampose包
    - [x] mesh 不显示：尺度变换错误，尺度太小导致看不见
    - [x] 确认 marker 的固联坐标系：见 手写笔记

- [x] 确定状态量、 观测量、因子（约束）：
  - [x] 状态
    - [x] geo_T_slamp
  - [x] 观测量 与 因子
    - [x] Local Factor(VIO) 
    - [x] GPS Factor 
    - [x] Magnetmeter Factor

- [x] 确定数据结构
  - [x] 阅读 test_PGO
  - [x] 安装源码版 pycolmap

- [x] 初始化：
  - [x] NED 坐标系下轨迹各帧初始值 = SE(3) * slam_pose
  - [x] 先将 localkit 的经纬度变换到 地理系 
  - [x] 确定平移部分：x、y 从 slampose 和 localkit 最近邻点对来获取，然后取个平均
  - [x] 确定旋转部分：yaw从磁力计获取、或者从已有轨迹和地图对齐考虑


- [x] 约束与优化：
  - [x] Local Factor(VIO): slampose 帧间位姿
  - [x] wifi/GPS Factor: localkit 找时间上最近邻的帧施加约束
  - [x] manhattan yaw
    - [x] 施加 yaw offset
    - [x] 读取 mgw 数据
    - [x] 预处理 mgw 数据
    - [x] 构建约束，和 location 一起
  - [ ] Magnetmeter Factor: 磁力计施加的 yaw 约束
  - [ ] huber 鲁棒核函数

- [x] 数据输出
  - [x] 结果转换为 rpy
  - [x] 结果打包到 list
  - [x] 按指定格式，写到指定位置下的 csv
  - [x] 0-6 数据集rosbag 图片 265 张，但 slampose 有 267 个，转成 rosbag 有点问题

- [ ] 高频传播：
  - [ ] imu propagate

一些初步结论：
- mgw 姿态比 slampose 的姿态好，因此输出只输出 mgw 的角度
- mgw 姿态 和 slampse 的平移初始值共同构成 AbsPose 先验，这个先验的方差如果设置小，也就ishi比重大一些后，会导致整体的轨迹尺度发散，这就导致 mgw 的权重无法太大，因此变成了辅助定位

第一帧使用 mag_in_imu 计算的 T 有误，甚至会影响到尺度
- 0
       mgw      slampose
  - 0: back	b
  - 1: forward	b
  - 2: b        b
  - 3: f        b
  - 4: b	b
  - 5: f	b
  - 6: b	b
  - 7: b	b
  - 8: f	b

旋转错误
- 0-4 
- 0-8
- 1-0
- 1-1	

---

pytorch 与其他框架训练的网络如何交互：onnx 开放神经网络交换

分为用于实验的即时模式，和用于高性能执行的图形模式


反向模式自动微分，Chainer
- 写一个子程序计算函数值 f(x)
- 


[A simple explanation of reverse-mode automatic differentiation](https://justindomke.wordpress.com/2009/03/24/a-simple-explanation-of-reverse-mode-automatic-differentiation/)

backpropagation algorithm:
- 本质上是链式法则

```
n = 4, N = 7

1    2    3    4
 5(1,2)  6(1, 3, 4)
      7(5, 6)

x_i <- f_i(X_{/pi(i)})
i = n + 1, ... , N


dxN/dxN <- 1
dxN/dxi <- \sum_{k: i = /pi(k)} dxN/dxk * dfk/dxi
i = N-1, N-2, ... , 1


```

```
  graph (1)

1  x1   1
   | \ /
   v  v
2  x2 x3
    \ /
     v
3    x4

x1.need_grad()
1. x2 <- f2(x1) = x1
2. x3 <- f3(x1, 1) = x1 - 1
3. x4 <- f4(x2, x3) = x2 * x3

dx4/dx4 = 1
3. dx4/dx3 = dx4/dx4 * df4/dx3 = x2
2. dx4/dx2 = dx4/dx4 * df4/dx2 = x3
1. dx4/dx1 = dx4/dx2 * df2/dx1 + dx4/dx3 * df3/dx1
           = x3 * 1 + x2 * 1
           = x1 - 1 + x1
           = 2x1 - 1

  graph (2)

1  x1
   | \
   |  v
2  |  x2
   | /
   v
3  x3

x1.need_grad()
1. x2 <- f2(x1) = x1 - 1
2. x3 <- f3(x1, x2) = x1 * x2

dx3/dx3 = 1
2. dx3/dx2 = dx3/dx3 * df3/dx2 = x1
1. dx3/dx1 = dx3/dx3 * df3/dx1 + dx3/dx2 * df2/dx1
           = x2 + x1 * 1
           = x1 - 1 + x1
           = 2x1 - 1

```

graph


The biggest difference is that autodiff can differentiate algorithms, not just expressions


---

2024-04-20

PyTorch is a Python-based scientific computing package serving two broad purposes:

A replacement for NumPy to use the power of GPUs and other accelerators.

An automatic differentiation library that is useful to implement neural networks.


---


[Pi0](https://www.bilibili.com/video/BV1mERzYvE4j/?spm_id_from=333.1007.tianma.2-2-5.click&vd_source=e371652571b1539bbd501fb7adb6cfc4)


1. 社区更好地掌握了创建可迁移通用模型的方法，使得微调或零样本迁移到其他机器人上成为可能
2. 视觉语言模型，让机器人能够理解环境中的语义
3. 强化学习领域的进步，使系统的健壮性、可靠性、性能得到突破


---

[](https://www.bilibili.com/video/BV1qqUaYmENu/?spm_id_from=333.788.recommend_more_video.-1&vd_source=e371652571b1539bbd501fb7adb6cfc4)

LLM：文字 -> 文字
VLM：图片+文字 -> 文字
VLA：图片+文字+Robot Action Data -> Robot Action Data

通用模型比专用系统表现更好
纳入异质数据源显著提升了繁华能力


训练基础模型的流程：
- 预训练：爬虫、筛选巨大的预训练数据集 -> 设计网络架构（一般是 Transformer）-> 设计训练目标
- 



---

C 语言模板库得到的启示：

如何在 C 语言中构建 类 呢
- 使用结构体 struct
  - property：需要初始化的成员变量
  - value：用于缓存
  - 函数指针

使用的步骤：
 - 核心思路是三步走：
    - 成员变量（普通变量+函数指针）初始化（赋初值）
    - 通过函数指针调用算法初始化函数
    - 再通过函数指针调用逻辑执行函数

 - C++ 有构造函数，而在 C 里，则需要单独写一个 全局函数，用于将 函数指针 绑定（被赋值）到某个具体的函数实现上


---

- [ ] 把 DD 相关的写完，总结好

- [ ] vins 初始化流程
  - [x] c0bk 意味着是以 c0 为参考，因此尺度 s 不确定

- [ ] 理解 plnet 的 pipline 以及 数据结构
  - [ ] pipline、基本公式（如果有的话）
  - [ ] 如何在代码上把 onnx 转成 engine
  - [ ] 数据结构

- [ ] 自己实现一个智能指针

- [ ] 初学 diffusion 原理

- [ ] 初学 RL 原理



---

依赖：
- NvOnnxParser.h
- 3rdparty/tensorrtbuffer/include/buffers.h
- Eigen/core
- opencv.hpp


resize 图片相关:
- input_width, input_height


---

keynote: The Real Problem of C++ - Klaus


c++ has a safety problem
- yes if you still have the "classic C++" midset

always choose perfomence, cuz:
- YES: safe over fast
- NO: fast over safe

topic:
- Bound Safety
- Type Safety
- Initialization Safety
- Lifetime Safety
- Undefined Behavior
 
1. Bound Safety	

The first part about ranges and not using loops, that's mainly about using a declarative style - so that your code says what it does, but not how it does that, and every common part of the logic (like take) is a separate library function (tested billions times unlike the for loop you make instead). 



- the "Ranges" style.
```
std::ranges::sort()
```

和 `std::sort` 有什么区别?

- **No Raw Loops**

代码示例见视频


2. undedined Behavior

- using `constexpr`
`-std=c++20` 才好用，否则无法在 constexpr 的函数内创建 vector 等数据结构

- complier explorer 是个好工具

- 函数只能全特化，不能偏特化（全特化意味着template<>，也就是括号里得为空，然后在函数名后3所有具体的类型名）


---


Back to the Basics

- Tour to C++

## 1 prefer range-for 

why do this: 
```
for ( auto i = begin(c); i != end(c); i++ ) { ... use(*i); ...}
```

when you can do this: 
```
for (auto& e: c) { ... use(e); ... }
```
## 2 Use smart pointers effectively, but still ** use lots of raw * and & **, they're great!

Dont's use owning `*`, `new` or `delete`. Except: Encapsulated inside the implementation of low-level data structures.

For "new", use `make_unique` by default, make_shared if it will be shared. For "delete", write nothing.

Example: 
- c++98 (now mostly wrong)
```c++
widget* factory();
void caller()
{
  widget* w = factory();
  gadget* g = new gadget();
  use( *w, *g );
  delete g;
  delete w;
}
```
- Modern C++:
```c++
unique_ptr<widget> factory();
void caller()
{
  auto w = factory();
  auto g = make_unique<gadget>();
  use( *w, *g );
}
```

NB: Non-Owing */& Are Still Great.

Why: 被调用者在调用者的生命周期内，不需要做所有权转移（you don't need ownership transfer down to call stack unless you're going to take something out of the call stack）

Example:
- C++98 "Classic":
```c++
void f( widget& w )  // if required
{
  use(w);
}

void g( widget* w )  // if optional
{
  if(w) use(*w);
}
``` 
- Modern C++ "Still Classic":
```c++
void f( widget& w )  // if required
{
  use(w);
}

void g( widget* w )  // if optional
{
  if(w) use(*w);
}
``` 
How to use those functions:
```c++
auto upw = make_unique<widget>();
...
f( *upw );

auto spw = make_shared<widget>();
...
g( spw.get() );
```

Antipatterns Hurt Pain Pain

Antipattern #1: Parameters (Note: Any refcounted pointer type.)
```
void f( refcnt_ptr<widget>& w )
{
  use(*w);
} // ?

void f( refcnt_ptr<widget> w )
{
  use(*w);
} // ?!?!
```
前者想避免计数，但会带来歧义：要更改指针的指向吗

后者带来性能上的恶化：每次进出函数都会递增和递减，而这些操作是原子操作，需要同步，因此开销并不小。

在这二种进行选择是一种 过早悲观：因为在都很复杂的操作中选择了更快，或者说在更快和更复杂中进行选择。
因此不如直接使用 raw */&

Antipattern #2: Loops (Note: Any refcounted pointer type.)
```
refcnt_ptr<widget> w = ...;
for (auto& e: baz) {
  auto w2 = w; // ?!?!?!?!
  use( w2, *w2, w, *w, whatever);
} // ?!?!?!?!
```
在循环中复制智能指针，缺点仍是带来大的开销

example:
In late 2013, Facebook RocksDB changed from pass-by-value shared_ptr to pass */&. QPS improveed 4x (100K to 400K) in one benchmark. 
[http://tinyurl.com/gotw91-example](http://tinyurl.com/gotw91-example)

什么时候才 copy/assigns smart pointer?

- refcounted smart pointers are about managing the owned object's lifetime.

- Don’t pass a smart pointer as a function parameter unless you want to use or manipulate the smart pointer itself, such as to share or transfer ownership.

- Prefer passing objects by value, *, or &, not by smart pointer.

- Express a “sink” function using a by-value unique_ptr parameter.

- Use a non-const unique_ptr& parameter only to modify the unique_ptr.

- Don’t use a const unique_ptr& as a parameter; use widget* instead.

- Express that a function will store and share ownership of a heap object using a by-value shared_ptr parameter.

- Use a non-const shared_ptr& parameter only to modify the shared_ptr. Use a const shared_ptr& as a parameter only if you’re not sure whether or not you’ll take a copy and share ownership; otherwise use widget* instead (or if not nullable, a widget&).


```c++
unique_ptr<widget> factory();		// source - produces widget
void sink( unique_ptr<widget> );	// sink - consumes widget
void reseat( unique_ptr<widget>& );	// "will" or "might" reseat ptr
void thinko( const unique_ptr<widget>& )// usually not what you want

shared_ptr<widget> fractory();		// source + shared ownership
	// when you know it will be shared, perhapsby factory itself
void share( shared_ptr<widget> )	// share - "will" make a copy 
					// and retain refcount
void reseat( shared_ptr<widget>& )	// "will" or "might" reseat ptr
void may_share( const shared_ptr<widget>& ) // "might" retain refcount
					// conditionally keep a copy
```

- [ ] 疑惑：返回类型是 unique_ptr<widget> ，可以 return widget* 类型吗

Not quite done: One guiline missing, and it applies to any RC pointer type, in almost any language / library

Guideline: Dereference Unaliased+Local RC Ptrs
只对 非别名且局部 的 引用计数指针 解引用 
否则指针可能在使用前已经被完全释放了 [0:27:19]



## use auto

- To make type track, deduce:
```
auto var = init;
```
- To make type stick, commit:
```
auto var = type{ init };
// or
type var{ init };
```
Reason:
- Counterarguments reflects bias to code against implementation, not interfaces.
- conrrectness + maintainability 当类型变动时，能够自动推导类型,减少思考，避免修改遗漏带来的编译错误 或 隐式转换（额外开销 or narrow conversion 精度下降，引出了第三点理由）
- performance
- usability (一些变量名字很长，很难拼写，所以用 auto 可以少打字)

Left-toright auto style:
[0:44:26]

(The) case where you can't use "auto style"
[0:47:35]

增加可读性的一个例子：
[0:49:18] 显式地表达了转换
```c++
base* pb = new derived();  // old fasion
unique_ptr<base> pb = make_unique<derived>();  // modern but too subtle
auto pb = unique_ptr<base>{ make_unique<derived>() }; //explicit and clear
```

## Use return-by-value way more often
but Don't overuse pass-by-value

Just as exception safey isn't about writing try and catch, using move semantick isn't all about writing move and &&

table:[0:58:29]

When do I write rvalue &&? Only to write rvalues.

no alloc -> noexcept

an example/question to show when use rvalue optim:

```
class employee {
  std::string name_;
public:
  void set_name(/* ?? */) { /* ?? */ }
}
```
1. default: `void set_name( const std::string& name ) { name_ = name; }`

1 copy assignment in body, for small string (SSO, small string optimization) no alloc, for large string <50% time alloc

2. optimized to steal from rvalues: add overload for string&& + move
```
void set_name( std::string&& name ) noexcept { 
  name_ = std::move(name); }
```
- pass a named obj: 1 copy assignment, <50% alloc, as before
- pass a temporary: 1 move assignment, ~5 ints, no alloc -> noexcept
- Note: conbinatorial if multiple "in + retain copy" parameters (e.g. 3 params need to write 2^3 = 8 function overload)

3. string + move, optimized to steal from rvalues, without overloading: 
```
void set_name( std::string name ) noexcept {
  name_ = std::move(name);
}
```
- pass named obj, 1 copy construction (100% alloc if long) + move op=
- pass a temporary: 1 move construction, 1 move assignment(~5 ints, no alloc -> noexcept-ish)
- this "noexcept" is problematic, why? because it is technically true, your code will complie, but you push the operation that might throw into the caller. If one usr has an lvlaue and he calls this function, a copy will be performed, that copy could perform an allocation, that allocation could fail, that could throw.


for vector & large string
| | construction | assignment / operator= |
|-|-|-|
| default | $$ |x|
| move | $$ | $ |
| copy | $$$ | $$$ |


## One Quiz

```
void foo( X&& x );

template<class Y>
void foo( Y&& y );
```

`X&&` 和 `Y&&` 有什么区别呢？
- `X&&` 表示函数只接受 rvalue
- `Y&&` 表示函数接受任何类型，包括 lvalue、rvalue、const、nonconst等，称之为 forward reference


## Dessert Slides

这个正好解决了我这段时间的疑问。

Use *turple* for multiple return values.

```
// C++98

pair<set<string::iterator, bool>> result = myset.insert( "Hello" );
if (result.second) do_something_with( result.first );  // workaround

// C++11 - sweet backword compat
auto result = myset.insert( "Hello" );  // nicer syntax, and the
if (result.second) do_something_with( result.first );  // workaround still work

// C++ - sweet forword compat, can treat as multiple return values
tie( iter, sucess ) = myset.insert( "Hello" );
if (success) do_somthing_with( iter );

```

## Summery
loops
pointers & references
smart pointers
variable declaaration
parameter passing

---

`explicit` 关键字用于一个参数的函数，一般用于 构造函数，禁止隐式转换的发生


boost::bind 可以在运行时动态创建 可调用对象

如果函数不在类内，则 
```
int add(int a, int b) { return a + b; }
auto add2 = boost::bind(add, 2, _1);
add2(3); // 5
```
否则：
```
one_class(){
  ...
  _one_thread = std::thread(std::bind(&one_class::method, this));
  ...
}
```

---

RAII(Resource Acquisition Is Initialization):
资源获取即初始化。利用存储在栈的对象，来管理资源

1. 设计一个类封装资源
2. 在构造函数中初始化资源
3. 在析构函数中销毁资源
4. 使用时声明一个该类的对象

[c++经验之谈一：RAII原理介绍](https://zhuanlan.zhihu.com/p/34660259)
---

一个 procedure A 调用另一个 procedure B 时，计算机需要干的事情：

1. 转移控制
2. 转移数据
3. 分配和释放内存


```c
int fact(int n)
{
  int result;
  if (n <= 1)
    result = 1;
  else
    result = n * fact(n-1);
  return result;
}
```


main() -> fact(n) -> fact(n-1) 即将-> fact(n-2)
的 call stack: 

```
      (stack top)
  +-----------------+ <-- stack pointer (SP)
  |      n - 2      | \  
  +-----------------+  | 
  |      result     |   > frame for fact(n-1)
  +-----------------+  | 
  |  saved register | /  
  +-----------------+
  |  return address | \  
  +-----------------+  |  
  |      n - 1      |  | 
  +-----------------+   > frame for fact(n)
  |      result     |  | 
  +-----------------+  |
  | saved registers | /
  +-----------------+
  |  return address | \  
  +-----------------+  | 
  |        n        |   > frame for main()
  +-----------------+  | 
  |       ...       | /  
  +-----------------+
    (stack "bottom")
```
---


# 设计模式

[工厂模式比较](https://refactoringguru.cn/design-patterns/factory-comparison)

- 构建方法：返回一个对象的函数或方法
```c++
class number {
  number(v): value(v) {}
  unique_ptr<widget> nextFactory() {
    return make_unique<number>(value + 1);
  }
private:
  int value;
}
```

- 简单工厂模式

简单工厂通常没有子类。 但当从一个简单工厂中抽取出子类后， 它看上去就会更像经典的工厂方法模式了。

```c++
class Button {/* ... */}; 
class WinButton: Botton {/* ... */};
class MacButton: Botton {/* ... */};

class ButtonFactory {
  unique_ptr<Button> create(string type) {
    switch (type) {
      case "Mac": return make_unique<MacButton>
      case "Win": return make_unique<WinButton>
      default: cout << "Wrong type." << endl; return nullptr;
    }
  }
}
```


- 工厂方法模式
```c++
class Button {/* ... */}; 
class WinButton: Botton {/* ... */};
class MacButton: Botton {/* ... */};

class ButtonFactory {
  vitual unique_ptr<Botton> createButton()=0;
}

class MacButtonFactory: ButtonFactory{
  unique_ptr<Botton> createButton() {
    return make_unique<MacButton>();
  }
}

class WinButtonFactory: ButtonFactory{
  unique_ptr<Botton> createButton() {
    return make_unique<WinButton>();
  }
}
```


- 抽象工厂

抽象工厂 是一种创建型设计模式， 它能创建一系列相关或相互依赖的对象， 而无需指定其具体类。

什么是 “系列对象”？ 例如有这样一组的对象：运输工具+ 引擎+ 控制器 。 它可能会有几个变体：

1. 汽车+ 内燃机+ 方向盘
2. 飞机+ 喷气式发动机+ 操纵杆

如果你的程序中并不涉及产品系列的话， 那就不需要抽象工厂。

再次重申， 许多人分不清抽象工厂模式和声明为 abstract的简单工厂。 不要犯这个错误！

example:

产品结构：

```
class Button; // Abstract Class

class MacButton: public Button {};

class WinButton: public Button {};

class Border; // Abstract Class

class MacBorder: public Border {};

class WinBorder: public Border {};
```

对应的工厂：

```
class AbstractFactory {
public:
    virtual Button* CreateButton() =0;
    virtual Border* CreateBorder() =0;
};

class MacFactory: public AbstractFactory {
public:
    MacButton* CreateButton() { return new MacButton; }
    MacBorder* CreateBorder() { return new MacBorder; }
};

class WinFactory: public AbstractFactory {
public:
    WinButton* CreateButton() { return new WinButton; }
    WinBorder* CreateBorder() { return new WinBorder; }
};
```
那么客户可以根据需要选择 Mac 风格或者 Win 风格来创建 Button 或 Border:

```
AbstractFactory* fac;
switch (style) {
case MAC:
    fac = new MacFactory;
    break;
case WIN:
    fac = new WinFactory;
    break;
}
Button* button = fac->CreateButton();
Border* border = fac->CreateBorder();
```

---


## lambda

```
 1
 ^
/ \
[=] () mutable throw() -> int
{
  int n = x + y;

  x = y;
  y = n;

  return n;
}
```


---

- [x] “发明内容“后半部分：增加三步骤的图；文字部分
- [x] ”具体实施方式二：边界跟踪算法“ 修改公式，以及配图
- [x] 权利要求书对应的公式
- [x] 更新表 1
- [ ] 解决 visio 图模糊


---


# Coding isn't Programming 

[Coding isn't Programming(Leslie Lamport)](https://www.bilibili.com/video/BV1HJRyYgE4j/?spm_id_from=333.1387.favlist.content.click&vd_source=e371652571b1539bbd501fb7adb6cfc4)

算法不应该被用特定的编程语言来表示，
应该关注想法，而不是使用哪种语言

- 因为具体的编程语言需要考虑 高效的执行 和 大型程序


并发（concurrancy）算法和程序一样难写，但算法更简单

抽象

- thinking before you code
- thinking at a higher level than code

For most programs, you should write two things:
- What the program does.
- How the program does it.































